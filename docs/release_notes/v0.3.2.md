# Jiva v0.3.2 - Bug Fix & Quality Improvement Release

**Release Date:** February 16, 2026  
**Type:** Bug Fix + Quality Improvement Release

## Overview

Version 0.3.2 is a focused bug fix and quality improvement release addressing critical issues with multi-agent persona management, workspace context propagation, model temperature settings, and HTTP/cloud deployment compatibility. Additionally, it introduces significant enhancements to Client agent validation through LLM-based semantic analysis and coherence checking.

**Key Highlights:**
- üîß **4 Critical Bug Fixes**: Persona isolation, context propagation, enhanced logging, reduced hallucination
- üö® **3 HTTP/Cloud Fixes**: Per-tenant persona config (CRITICAL), session-scoped logging, cloud-aware orchestration logging
- üß† **5 Quality Improvements**: LLM-based validation, coherence checking, robust plan parsing, orchestration logging, actionable feedback
- ‚úÖ **Production Ready**: Now fully compatible with concurrent HTTP sessions and Cloud Run deployments
- üìä **Enhanced Observability**: Comprehensive orchestration logging for all three agents (Manager, Worker, Client)

These improvements significantly boost agent reliability, reduce hallucination, enhance trustworthiness of outputs, provide complete visibility into multi-agent orchestration, and ensure seamless operation in production cloud environments with **true multi-tenant isolation**.

## Bug Fixes

### üîß Fixed Persona Persistence Corruption

**Issue:** When a parent agent (e.g., `engineering-manager`) spawned a sub-agent with a different persona (e.g., `tester`), the sub-agent's persona activation overwrote the parent's persona in the global configuration. After the sub-agent completed, the global config showed the sub-agent's persona instead of the parent's.

**Root Cause:** `ConfigManager` is a singleton shared by all agents. When sub-agents activated their persona, they persisted it to the same global config file (`~/Library/Preferences/jiva-nodejs/config.json`), overwriting the parent agent's active persona.

**Fix:** Introduced **ephemeral mode** for `PersonaManager`:
- Parent agents use persistent `PersonaManager` (ephemeral=false)
- Sub-agents use ephemeral `PersonaManager` (ephemeral=true)
- Ephemeral personas exist only in memory and don't persist to config
- Each agent maintains its own persona state throughout execution lifecycle

**Files Changed:**
- `src/personas/persona-manager.ts` - Added ephemeral constructor parameter
- `src/core/agent-spawner.ts` - Sub-agents now use ephemeral PersonaManager
- `src/core/dual-agent.ts` - Top-level agents use persistent PersonaManager

**Result:** Parent agent persona remains active and persisted correctly, even after spawning multiple sub-agents with different personas.

### üó∫Ô∏è Fixed Workspace Context Propagation

**Issue:** Workspace directory was not automatically passed to spawned sub-agents in the task message context. While the sub-agent's system prompt included the workspace path, the initial task context might not have explicitly included it if the parent agent forgot to provide it.

**Root Cause:** `AgentSpawner.spawnAgent()` only included the workspace path if the parent agent remembered to include it in the optional `context` parameter.

**Fix:** Automatically inject workspace path into all sub-agent task messages:
```typescript
const workspacePath = this.workspace.getWorkspaceDir();
let contextSection = `Project root: ${workspacePath}`;

if (request.context) {
  contextSection += `\n${request.context}`;
}

const taskMessage = `CONTEXT:\n${contextSection}\n\nTASK:\n${request.task}`;
```

**Files Changed:**
- `src/core/agent-spawner.ts` - Workspace path now automatically prepended to context
- `src/core/worker-agent.ts` - Updated spawn_agent documentation

**Result:** All spawned sub-agents now receive the workspace path automatically, regardless of whether the parent provides additional context.

### üìä Added Persona Context to Logs

**Issue:** In multi-agent scenarios with persona spawning, logs from different agents appeared identical, making it difficult to trace which persona/agent was executing at any given time.

**Fix:** Enhanced logger to include persona context in all log messages:
- Added `setPersonaContext()` and `getPersonaContext()` to Logger
- Manager and Worker agents set persona context on initialization
- AgentSpawner saves parent context, sets sub-agent context, and restores parent context after execution
- Log format now includes persona name in magenta: `[persona-name]`

**Example Log Output:**
```
2026-02-16T03:47:42.002Z [INFO] [engineering-manager] Creating plan...
2026-02-16T03:47:42.150Z [INFO] [engineering-manager] Delegating to Worker
2026-02-16T03:47:42.200Z [INFO] [tester] Starting subtask...
2026-02-16T03:47:43.500Z [INFO] [tester] Writing test files...
2026-02-16T03:47:44.000Z [SUCCESS] [engineering-manager] Sub-agent completed
```

**Files Changed:**
- `src/utils/logger.ts` - Added persona context tracking and formatting
- `src/core/manager-agent.ts` - Sets persona context in constructor
- `src/core/worker-agent.ts` - Sets persona context in constructor
- `src/core/agent-spawner.ts` - Context switching for sub-agents with try-finally cleanup

**Result:** Clear visibility into which persona/agent is executing at any time, making debugging and monitoring significantly easier.

### üéØ Reduced Model Temperature to Minimize Hallucination

**Issue:** Default temperature settings (0.3-0.7) caused agents to occasionally hallucinate or make up information instead of using tools, especially when reporting task completion without taking action.

**Fix:** Systematically reduced temperature across all agent interactions to promote deterministic, fact-based behavior:

| Component | Before | After | Purpose |
|-----------|--------|-------|---------|
| Manager Agent | 0.3-0.5 | 0.1 | Deterministic planning/decisions/synthesis |
| Worker Agent | 0.3 | 0.1 | Deterministic tool execution |
| Client Agent | 0.1 | 0.1 | Already optimal for validation |
| Conversation Manager | 0.3 | 0.1 | Deterministic title/summary generation |
| Default (Krutrim) | 0.7 | 0.2 | Reduced baseline hallucination |
| Default (Agent) | 0.7 | 0.2 | Reduced baseline hallucination |

**Rationale:**
- **Temperature controls creativity vs determinism**: Lower = more factual/consistent, Higher = more creative/random
- **0.1 for critical paths**: Planning, tool execution, validation all require deterministic behavior
- **0.2 conservative default**: Fallback for custom uses where determinism is still preferred
- **Hallucination reduction**: Agents now strictly follow tool results and facts

**Files Changed:**
- `src/core/manager-agent.ts` - Planning (0.3‚Üí0.1), decisions (0.3‚Üí0.1), synthesis (0.5‚Üí0.1)
- `src/core/worker-agent.ts` - Tool execution (0.3‚Üí0.1)
- `src/core/conversation-manager.ts` - Titles/summaries (0.3‚Üí0.1)
- `src/models/krutrim.ts` - Default temperature (0.7‚Üí0.2)
- `src/core/agent.ts` - Default temperature (0.7‚Üí0.2)

**Result:** Significantly reduced hallucination and false completions. Agents now stick to facts, use tools consistently, and report accurate results based on actual tool outputs.

## HTTP/Cloud Compatibility Fixes

During validation of the v0.3.2 improvements against the HTTP interface for web/cloud deployments, we discovered and fixed **three critical concurrency issues**:

### üö® Per-Tenant Persona Configuration (CRITICAL FIX)

**Problem:** PersonaManager used `ConfigManager` singleton which stores to local filesystem (`~/Library/Preferences/jiva-nodejs/config.json`). This config is **shared across all tenants** in the same Cloud Run container instance, causing race conditions and cross-tenant data leakage.

**Impact:**
- User A (tenant-alice) activates "engineering-manager" persona ‚Üí writes to global config
- User B (tenant-bob) activates "data-analyst" persona ‚Üí **overwrites User A's setting**
- User A's next request incorrectly sees "data-analyst" persona ‚ùå
- **CRITICAL**: Persona configuration was NOT isolated per tenant
- **SECURITY**: Tenants could inadvertently affect each other's settings

**Example Scenario:**
```typescript
// Request 1: Alice activates engineering-manager
POST /api/chat (tenant: alice) 
// PersonaManager ‚Üí ConfigManager.setActivePersona('engineering-manager')
// Written to: ~/Library/.../config.json (shared!)

// Request 2: Bob activates data-analyst
POST /api/chat (tenant: bob)
// PersonaManager ‚Üí ConfigManager.setActivePersona('data-analyst')  
// Overwrites: ~/Library/.../config.json (same file!)

// Request 3: Alice sends message
POST /api/chat (tenant: alice)
// PersonaManager.initialize() ‚Üí reads config
// Gets: 'data-analyst' ‚ùå WRONG! Should be 'engineering-manager'
```

**Fix:**
- Added optional `StorageProvider` parameter to PersonaManager constructor
- When StorageProvider is provided (HTTP/Cloud mode), persona config is stored at `{tenantId}/personas/config.json` in GCS
- When StorageProvider is null (CLI mode), falls back to global ConfigManager (existing behavior)
- New helper methods:
  - `getPersistedActivePersona()` - Reads from storage (cloud) or ConfigManager (CLI)
  - `persistActivePersona()` - Writes to storage (cloud) or ConfigManager (CLI)
- SessionManager now passes StorageProvider when creating PersonaManager
- Made `activatePersona()` and `deactivatePersona()` async to support storage operations

**Files Changed:**
- `src/personas/persona-manager.ts` - Added StorageProvider support, async config persistence
- `src/interfaces/http/session-manager.ts` - Pass StorageProvider to PersonaManager  
- `src/interfaces/cli/index.ts` - Await async persona methods
- `src/core/agent-spawner.ts` - Updated comment about CLI mode

**Result:** Each tenant's persona configuration is now fully isolated in their own GCS path `{tenantId}/personas/config.json`. Zero chance of cross-tenant interference. CLI mode continues working as before with global config.

### üåê Session-Scoped Logger for Concurrent HTTP Sessions

**Problem:** Logger used a singleton pattern with a single `personaContext` field. In multi-tenant HTTP environments with concurrent sessions, different sessions would overwrite each other's persona context, causing logs to show incorrect persona names.

**Impact:** 
- Session A (tenant-1) sets persona "engineering-manager"
- Session B (tenant-2) sets persona "tester" ‚Üí **overwrites Session A's context**
- All logs from Session A now incorrectly show "[tester]" instead of "[engineering-manager]"

**Fix:** 
- Added session-scoped context storage: `Map<sessionId, personaContext>`
- Logger now tracks `currentSessionId` and uses per-session contexts in HTTP mode
- Fallback to global context for CLI single-session mode
- SessionManager sets session ID on logger for each session
- Session contexts are cleaned up when sessions end

**Files Changed:** `src/utils/logger.ts`, `src/interfaces/http/session-manager.ts`

**Result:** Each HTTP session maintains isolated persona context, logs show correct persona names even with 100+ concurrent sessions.

### ‚òÅÔ∏è Cloud-Aware Orchestration Logging

**Problem:** OrchestrationLogger wrote to `~/.jiva/logs/orchestration-{timestamp}.log` on the filesystem, which doesn't work in Cloud Run:
- Cloud Run containers are ephemeral and stateless
- Filesystem writes are lost on container restart
- No multi-tenant isolation (all sessions write to same directory)
- Logs not accessible via GCS

**Fix:**
- Added `StorageProvider` integration to OrchestrationLogger
- Dual-mode operation:
  - **CLI mode**: Writes to `~/.jiva/logs/` (existing behavior)
  - **HTTP/Cloud mode**: Buffers logs and flushes to `{tenantId}/sessions/{sessionId}/orchestration.log` via StorageProvider
- New `appendToLog(key, content)` method in StorageProvider for raw string appends
- SessionManager configures orchestration logger with storage provider per session
- Auto-flush on buffer threshold (100 events) or manual flush on session end

**Files Changed:** 
- `src/utils/orchestration-logger.ts` - Dual-mode logging
- `src/storage/provider.ts` - Added `appendToLog()` abstract method
- `src/storage/local-provider.ts` - Implemented `appendToLog()` for filesystem
- `src/storage/gcp-bucket-provider.ts` - Implemented `appendToLog()` for GCS
- `src/interfaces/http/session-manager.ts` - Configure orchestration logger per session

**Result:** Orchestration logs now persist correctly in cloud deployments, accessible via GCS at `gs://bucket/{tenantId}/sessions/{sessionId}/orchestration.log`, with full multi-tenant isolation.

## Quality Improvements

Beyond the critical bug fixes above, v0.3.2 includes significant quality improvements to the Client agent validation system and Manager agent planning:

### üß† Client Agent LLM-Based Validation

**What Changed:** Replaced keyword-based involvement level detection with semantic understanding powered by the LLM itself.

**Why:** The previous system used hardcoded keyword matching (e.g., "test" ‚Üí THOROUGH mode, "list" ‚Üí MINIMAL mode), which caused false positives. For example, "check how much space my caches use" would trigger browser testing validation because it contained "check," even though it's a simple system administration task.

**Implementation:**
- New `analyzeTaskRequirements()` method uses structured LLM prompting to determine:
  - Involvement level (MINIMAL/STANDARD/THOROUGH) based on task semantics
  - Specific requirements with type classification (file_creation, testing, verification, information)
  - Which tools must be used (if any) for each requirement
- Deprecated `determineInvolvementLevel()` and `parseRequirements()` kept for reference
- Semantic rules prevent false positives: "check disk space" ‚â† browser testing

**Example Analysis:**
```json
{
  "involvementLevel": "MINIMAL",
  "involvementReasoning": "Information-only task, no file creation or modification",
  "requirements": [
    {
      "type": "information",
      "description": "Report disk usage of cache directories",
      "mustUseTools": null
    }
  ]
}
```

**Files Changed:** `src/core/client-agent.ts`

**Result:** More accurate validation mode selection, significantly fewer false escalations to THOROUGH mode, better resource efficiency.

### üîç Coherence Checking for Hallucinated Accomplishments

**What Changed:** Added result-vs-evidence coherence analysis that cross-checks the Worker's claimed accomplishments against its actual tool usage.

**Why:** Agents sometimes claim to have "inspected all source files" or "found no bugs" when they only used `list_directory` and never actually read any file contents. This new layer catches fabricated claims.

**Implementation:**
- New `analyzeResultCoherence()` method runs at ALL involvement levels (including MINIMAL)
- Uses LLM to detect common hallucination patterns:
  - Claims to have "analyzed" or "reviewed" code without reading files
  - Claims "no bugs found" without reading source files
  - Claims to have run tests without executing shell commands
  - Provides specific code details (line numbers, variables) without reading relevant files
- Generates list of unsupported claims and actionable suggestions

**Example Detection:**
```
Worker Result: "I inspected all TypeScript files and found no issues."
Tools Used: filesystem__list_directory, filesystem__directory_tree
Coherence: INCOHERENT
Unsupported Claims: ["inspected all TypeScript files", "found no issues"]
Suggested Action: "Read the source files using filesystem__read_text_file before claiming to have analyzed them"
```

**Files Changed:** `src/core/client-agent.ts`, `src/utils/orchestration-logger.ts`

**Result:** Catches hallucinated accomplishments before they reach the user, forces agents to actually perform claimed work, significantly improves output trustworthiness.

### üìã Manager JSON Plan Parsing with Fallbacks

**What Changed:** Manager agent now requests JSON-formatted plans and includes multiple fallback layers when parsing fails.

**Why:** The previous text-based format (`REASONING: ... SUBTASKS: - ... - ...`) was fragile and sometimes produced garbage entries like markdown separators, prose fragments, or empty lines mixed with actual subtasks.

**Implementation:**
- Prompt modified to explicitly request JSON: `{ "reasoning": "...", "subtasks": [...] }`
- New `parseJsonPlan()` extracts first JSON object from response
- Fallback 1: If parsing fails, `cleanPlanWithLLM()` asks LLM to clean/reformat the output
- Fallback 2: If all else fails, treats raw content as single subtask
- New `validateSubtasks()` filters out:
  - Empty strings or entries < 5 characters
  - Markdown separators (---, ===, ***)
  - Pure punctuation/symbols
  - Non-actionable prose fragments

**Files Changed:** `src/core/manager-agent.ts`

**Result:** More reliable plan parsing, no garbage entries in subtask lists, graceful degradation when LLM doesn't follow format.

### üìù Client Agent Orchestration Logging

**What Changed:** Added comprehensive logging for all Client agent validation decisions.

**Why:** Client validation happens silently after Worker execution. Without logging, it was impossible to understand why a subtask was rejected or what specific validation checks failed.

**Implementation:**
- Added CLIENT phase to orchestration logger
- New log methods:
  - `logClientAnalysis()` - Records involvement level selection and requirements
  - `logClientCoherenceCheck()` - Records coherence analysis results
  - `logClientValidation()` - Records final approval/rejection decision
- Logs written to `~/.jiva/logs/orchestration-{timestamp}.log`

**Example Log Output:**
```
[2026-02-16T04:12:15.234Z] [CLIENT] TASK_ANALYSIS {"level":"STANDARD","requirementCount":2,"reasoning":"Requirements: file_creation, verification"}
[2026-02-16T04:12:16.105Z] [CLIENT] COHERENCE_CHECK {"isCoherent":false,"unsupportedClaimCount":1,"unsupportedClaims":["analyzed all files"],"reasoning":"Worker only listed directories"}
[2026-02-16T04:12:16.200Z] [CLIENT] VALIDATION_RESULT {"approved":false,"issueCount":1,"issues":["..."],"nextAction":"Read the files using filesystem__read_text_file"}
```

**Files Changed:** `src/utils/orchestration-logger.ts`, `src/core/client-agent.ts`

**Result:** Full visibility into Client validation logic, easier debugging of multi-agent orchestration, clear audit trail of quality control decisions.

### üéØ LLM-Generated Correction Instructions

**What Changed:** When validation fails, Client now uses LLM to generate actionable correction instructions instead of echoing raw validation errors.

**Why:** Previous corrections were technical and vague: "requires using playwright__ but Worker did not use these tools." Users and Worker agents need specific, actionable guidance.

**Implementation:**
- New `generateCorrectionInstruction()` method takes validation issues and generates clear instructions
- Considers original user request, subtask attempted, issues found, and Worker's tool usage
- Produces concise, direct commands (1-2 sentences)

**Example Transformation:**
```
Before: "Worker did not use required tools. This subtask requires using mcp-shell-server__ but Worker did not use these tools."

After: "Use the run_process tool from mcp-shell-server to execute 'du -sh ~/Library/Caches/*' and report the output with sizes."
```

**Files Changed:** `src/core/client-agent.ts`

**Result:** Worker agents receive clear, actionable feedback that tells them exactly what to do, faster convergence to correct behavior, reduced retry iterations.

## Technical Details

### Persona Lifecycle with Ephemeral Mode

```typescript
// Parent agent (persistent)
const parentPersonaManager = new PersonaManager([], false); // ephemeral=false
await parentPersonaManager.activatePersona('engineering-manager');
// Persists to config: activePersona: "engineering-manager"

// Sub-agent (ephemeral)
const subPersonaManager = new PersonaManager([], true); // ephemeral=true
await subPersonaManager.activatePersona('tester');
// Does NOT persist - stays in memory only

// After sub-agent completes
// Config still shows: activePersona: "engineering-manager" ‚úÖ
```

### Logger Context Switching

```typescript
// In AgentSpawner.spawnAgent()
const parentPersonaContext = logger.getPersonaContext(); // Save parent's persona

try {
  logger.setPersonaContext(request.persona); // Set sub-agent's persona
  const response = await subAgent.chat(taskMessage);
  // All logs during execution show [sub-agent-persona]
} finally {
  logger.setPersonaContext(parentPersonaContext); // Always restore parent
}
```

### Client Coherence Analysis Flow

```typescript
// Worker completes a subtask
workerResult = {
  success: true,
  result: "I analyzed all TypeScript files in src/ and found no bugs.",
  toolsUsed: ['filesystem__list_directory', 'filesystem__directory_tree'],
  reasoning: "..."
}

// Client performs coherence check
const coherence = await this.analyzeResultCoherence(userMessage, workerResult);
// {
//   isCoherent: false,
//   reasoning: "Worker claims to have analyzed TypeScript files but only listed directories, never read file contents",
//   unsupportedClaims: ["analyzed all TypeScript files", "found no bugs"],
//   suggestedAction: "Read the source files using filesystem__read_text_file before claiming analysis"
// }

// Validation fails due to incoherence
result.issues.push("REJECTED: Worker's result contains claims not supported by tool usage");
result.nextAction = coherence.suggestedAction;
```

### Manager Plan Validation

```typescript
// LLM returns plan (sometimes with garbage)
rawResponse = `{
  "reasoning": "...",
  "subtasks": [
    "Create the calculator app",
    "---",  // Markdown separator
    "",     // Empty line
    "Review the implementation",
    "***"   // More markdown
  ]
}`;

// Parse and validate
const plan = parseJsonPlan(rawResponse);
plan.subtasks = validateSubtasks(plan.subtasks);
// Result: ["Create the calculator app", "Review the implementation"]
// Filtered out: "---", "", "***"
```

### Session-Scoped Logging (HTTP/Cloud)

```typescript
// Concurrent HTTP sessions
// Session A (tenant-1, session-abc)
logger.setSessionId('session-abc');
logger.setPersonaContext('engineering-manager');
logger.info('Creating plan...');
// Output: [2026-02-16...] [INFO] [session-ab] [engineering-manager] Creating plan...

// Session B (tenant-2, session-xyz) - concurrent with A
logger.setSessionId('session-xyz');
logger.setPersonaContext('data-analyst');
logger.info('Analyzing data...');
// Output: [2026-02-16...] [INFO] [session-xy] [data-analyst] Analyzing data...

// Back to Session A - context preserved
logger.setSessionId('session-abc');
logger.info('Delegating to Worker...');
// Output: [2026-02-16...] [INFO] [session-ab] [engineering-manager] Delegating to Worker...
// ‚úÖ Correct persona context maintained!
```

### Cloud Orchestration Logging

```typescript
// SessionManager creates session
const session = await createSession(tenantId, sessionId);

// Configure orchestration logger for cloud mode
orchestrationLogger.setStorageProvider(storageProvider, sessionId);

// Agent executes - logs buffer in memory
orchestrationLogger.logManagerCreatePlan(task, context);
orchestrationLogger.logWorkerStart(subtask, context);
// ... 50 more events ...

// Auto-flush at 100 events or manual flush on session end
await orchestrationLogger.flush();

// Logs persisted to: gs://bucket/{tenantId}/sessions/{sessionId}/orchestration.log
// Accessible via GCS console or gsutil after session ends
```

### Per-Tenant Persona Configuration (HTTP/Cloud)

```typescript
// Before v0.3.2 (BROKEN - shared config)
// User A (tenant-alice)
const personaManagerA = new PersonaManager(); // Uses ConfigManager singleton
await personaManagerA.initialize();
await personaManagerA.activatePersona('engineering-manager');
// Writes to: ~/Library/Preferences/jiva-nodejs/config.json (SHARED!)

// User B (tenant-bob) 
const personaManagerB = new PersonaManager(); // Same ConfigManager singleton!
await personaManagerB.initialize();
await personaManagerB.activatePersona('data-analyst');
// OVERWRITES: ~/Library/Preferences/jiva-nodejs/config.json
// User A now sees 'data-analyst' ‚ùå

// After v0.3.2 (FIXED - per-tenant storage)
// User A (tenant-alice)
storageProviderA.setContext({ tenantId: 'alice', sessionId: 'session-1' });
const personaManagerA = new PersonaManager([], false, storageProviderA);
await personaManagerA.initialize();
await personaManagerA.activatePersona('engineering-manager');
// Writes to: gs://bucket/alice/personas/config.json (isolated!)

// User B (tenant-bob)
storageProviderB.setContext({ tenantId: 'bob', sessionId: 'session-2' });
const personaManagerB = new PersonaManager([], false, storageProviderB);
await personaManagerB.initialize();  
await personaManagerB.activatePersona('data-analyst');
// Writes to: gs://bucket/bob/personas/config.json (different path!)
// User A's config unchanged ‚úÖ
```

## Compatibility

- **Backward Compatible:** No breaking changes
- **Config Migration:** Existing configs work without modification
- **API Stability:** All public APIs remain unchanged
- **Storage:** No changes to storage layer

## Upgrade Instructions

### NPM Users

```bash
npm install -g jiva-core@0.3.2
```

### Git Users

```bash
cd Jiva
git pull
npm install
npm run build
```

### Cloud Run Users

Update your deployment:
```bash
./deploy.sh YOUR_PROJECT_ID REGION
```

## Verification

After upgrading, verify the fixes:

### 1. Check Persona Persistence

```bash
# Activate a persona
jiva persona activate engineering-manager

# Spawn sub-agents (try a complex task that spawns multiple agents)
jiva chat
You: Build a feature with code review and tests

# After completion, check active persona
jiva persona list

# Should still show engineering-manager as active ‚úÖ
```

### 2. Verify Workspace Context in Logs

```bash
jiva chat --debug
You: Use spawn_agent to delegate a task

# Check logs - should see workspace path in sub-agent context
```

### 3. Observe Persona in Logs

```bash
# All logs should now include [persona-name]
# Example: [INFO] [engineering-manager] Creating plan...
#         [INFO] [tester] Starting subtask...
```

### 4. Verify Reduced Hallucination

Run tasks that previously showed hallucination:
- Agents should use tools more consistently
- Fewer "I completed the task" without evidence
- More accurate reporting of actual tool results

### 5. Test Client Coherence Checking

```bash
jiva chat
You: Analyze all source code files and report any bugs

# If Worker only lists directories without reading files,
# Client should reject with: "Read files using filesystem__read_text_file before claiming analysis"
# Check orchestration logs: ~/.jiva/logs/orchestration-*.log
# Should see COHERENCE_CHECK event with isCoherent: false
```

### 6. Verify LLM-Based Validation

```bash
jiva chat --debug
You: Check how much space my Downloads folder uses

# Client should correctly identify this as "information" type,
# NOT as browser testing (no playwright__ tools required)
# Check logs for TASK_ANALYSIS event showing correct involvement level
```

### 7. Test Per-Tenant Persona Isolation (HTTP/Cloud Only)

If testing HTTP deployment locally or on Cloud Run:

```bash
# Terminal 1: Activate persona for tenant A
curl -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -H "X-Tenant-Id: tenant-alice" \
  -H "X-Session-Id: session-1" \
  -d '{"message": "/persona activate engineering-manager"}'

# Terminal 2: Activate different persona for tenant B  
curl -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -H "X-Tenant-Id: tenant-bob" \
  -H "X-Session-Id: session-2" \
  -d '{"message": "/persona activate data-analyst"}'

# Terminal 1: Verify tenant A still has engineering-manager
curl -X POST http://localhost:8080/api/chat \
  -H "Content-Type: application/json" \
  -H "X-Tenant-Id: tenant-alice" \
  -H "X-Session-Id: session-1" \
  -d '{"message": "/persona list"}'
# Should show engineering-manager as active ‚úÖ

# Check GCS storage (if using Cloud Run)
gsutil cat gs://YOUR_BUCKET/tenant-alice/personas/config.json
# Should see: {"activePersona":"engineering-manager"}

gsutil cat gs://YOUR_BUCKET/tenant-bob/personas/config.json  
# Should see: {"activePersona":"data-analyst"}
# Confirms complete isolation ‚úÖ
```

## Known Issues

None identified in this release.

## Contributors

- Abi Chatterjee (@abichatterjee) - Bug fixes, quality improvements, and temperature tuning

## Summary Statistics

- **Files Modified:** 17 core files (8 original + 9 HTTP/multi-tenancy)
- **Bug Fixes:** 4 critical issues resolved
- **HTTP/Cloud Fixes:** 3 tenant isolation + concurrency issues resolved
  - üö® **Per-tenant persona config** (CRITICAL security fix)
  - Session-scoped logging
  - Cloud-aware orchestration logging
- **Quality Improvements:** 5 enhancements
- **New Methods:** 11 total
  - 6 for Client validation intelligence + Manager robustness
  - 3 for session-scoped logging and cloud storage integration
  - 2 for per-tenant persona configuration
- **Lines Changed:** ~1300 lines across validation logic, plan parsing, logging, HTTP interface, and tenant isolation
- **Backward Compatibility:** Fully backward compatible, seamless upgrade
- **Cloud Ready:** ‚úÖ Tested with concurrent sessions and true multi-tenant isolation

**‚ö†Ô∏è CRITICAL for Production:** If you're running Jiva in HTTP/Cloud mode (v0.3.1+), this update is **ESSENTIAL** to fix:
1. **Cross-tenant persona config leakage** (security issue)
2. Concurrent session logging issues
3. Cloud storage persistence

**Security Impact:** v0.3.1 allowed tenants to inadvertently overwrite each other's persona settings. v0.3.2 fixes this with per-tenant storage isolation.

## Next Steps

Version 0.3.3 will focus on:
- Web UI interface
- Enhanced persona skill routing
- Performance optimizations

---

For complete documentation, see the [Jiva Documentation](../../README.md).
